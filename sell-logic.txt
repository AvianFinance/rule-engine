// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4; 

import @openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol;
import @openzeppelin/contracts/security/ReentrancyGuard.sol;
import @openzeppelin/contracts/utils/structs/EnumerableSet.sol;
import @openzeppelin/contracts/interfaces/IERC721.sol;
import @openzeppelin/contracts/utils/Counters.sol;

error PriceNotMet(address nftAddress, uint256 tokenId, uint256 price);
error ItemNotForSale(address nftAddress, uint256 tokenId);
error NotListed(address nftAddress, uint256 tokenId);
error AlreadyListed(address nftAddress, uint256 tokenId);
error NoProceeds();
error NotOwner();
error NotApprovedForMarketplace();
error PriceMustBeAboveZero();

contract AvianSellExchange is ReentrancyGuard { 

	using Counters for Counters.Counter;
	using EnumerableSet for EnumerableSet.AddressSet;
	using EnumerableSet for EnumerableSet.UintSet;

	struct Listing_sell {address owner;address nftContract;uint256 tokenId;uint256 price;}

	event ItemListed(address indexed seller,address indexed nftAddress,uint256 indexed tokenId,uint256 price);
	event ItemCanceled(address indexed seller,address indexed nftAddress,uint256 indexed tokenId);
	event ItemBought(address indexed buyer,address indexed nftAddress,uint256 indexed tokenId,uint256 price);

	modifier notSListed		(address nftAddress, uint256 tokenId) {
		Listing_sell memory listing = s_listings[nftAddress][tokenId];
		if (listing.price > 0) {
		revert AlreadyListed(nftAddress, tokenId);
		}
		_;
	}

	modifier isSListed		(address nftAddress, uint256 tokenId) {
		Listing_sell memory listing = s_listings[nftAddress][tokenId];
		if (listing.price <= 0) {
		revert NotListed(nftAddress, tokenId);
		}
		_;
	}

	modifier isOwner		(address nftAddress,uint256 tokenId,address spender) {
		IERC721 nft = IERC721(nftAddress);
		address owner = nft.ownerOf(tokenId);
		if (spender != owner) {
		revert NotOwner();
		}
		_;
	}


} 

